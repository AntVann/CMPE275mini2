#!/usr/bin/env python3

import time
import threading
import grpc
from concurrent import futures

# Import the generated proto modules
# Note: These will be generated by running generate_proto.py
from proto import basecamp_pb2
from proto import basecamp_pb2_grpc


class BasecampClient:
    """Client for the Basecamp service."""

    def __init__(self, server_address):
        """Initialize the client with a server address."""
        # Set a timeout for gRPC calls (5 seconds)
        self.timeout = 5
        self.channel = grpc.insecure_channel(server_address)
        self.stub = basecamp_pb2_grpc.BasecampServiceStub(self.channel)
        self.running = True
        self.subscription_thread = None
        self.chat_thread = None
        self.query_thread = None

    def __del__(self):
        """Clean up resources when the client is destroyed."""
        self.running = False
        if self.subscription_thread:
            self.subscription_thread.join()
        if self.chat_thread:
            self.chat_thread.join()
        if self.query_thread:
            self.query_thread.join()
        self.channel.close()

    def send_message(self, sender_id, receiver_id, content):
        """Send a message to another process."""
        request = basecamp_pb2.MessageRequest(
            sender_id=sender_id,
            receiver_id=receiver_id,
            content=content,
            timestamp=int(time.time() * 1000),
        )

        try:
            response = self.stub.SendMessage(request, timeout=self.timeout)
            if response.success:
                print(f"Message sent successfully with ID: '{response.message_id}'")
                return response.message_id
            else:
                print(f"Server error: {response.error_message}")
                return None
        except grpc.RpcError as e:
            print(f"Error sending message: {e}")
            return None

    def subscribe_to_updates(self, subscriber_id, topics, callback):
        """Subscribe to updates from specific topics."""
        request = basecamp_pb2.SubscriptionRequest(
            subscriber_id=subscriber_id, topics=topics
        )

        def subscription_thread_func():
            try:
                # Create metadata with a deadline (use a much longer timeout for chat)
                metadata = [("deadline", str(time.time() + self.timeout * 10))]

                # Call with metadata
                for update in self.stub.SubscribeToUpdates(request, metadata=metadata):
                    if not self.running:
                        break
                    callback(update)
            except grpc.RpcError as e:
                print(f"Error subscribing to updates: {e}")

        self.subscription_thread = threading.Thread(target=subscription_thread_func)
        self.subscription_thread.daemon = True
        self.subscription_thread.start()
        return True

    def send_multiple_messages(self, messages):
        """Send multiple messages in a batch."""

        def message_generator():
            for msg in messages:
                yield basecamp_pb2.MessageRequest(
                    sender_id=msg["sender_id"],
                    receiver_id=msg["receiver_id"],
                    content=msg["content"],
                    timestamp=int(time.time() * 1000),
                )

        try:
            # Add timeout to the gRPC call (use a much longer timeout for multiple messages)
            response = self.stub.SendMultipleMessages(
                message_generator(), timeout=self.timeout * 10
            )
            print(f"Sent {response.success_count} messages successfully")
            if response.failure_count > 0:
                print(f"Failed to send {response.failure_count} messages")
            return response
        except grpc.RpcError as e:
            print(f"Error sending multiple messages: {e}")
            return None

    def start_chat(self, sender_id, receive_callback, get_next_message):
        """Start a chat session."""

        def chat_thread_func():
            try:
                # Create a generator for the request messages
                def request_iterator():
                    while self.running:
                        content = get_next_message()
                        if content is None:
                            break

                        message = basecamp_pb2.ChatMessage(
                            sender_id=sender_id,
                            content=content,
                            timestamp=int(time.time() * 1000),
                        )
                        yield message
                        time.sleep(0.1)  # Small delay between messages

                # Create metadata with a deadline (use a much longer timeout for chat)
                metadata = [("deadline", str(time.time() + self.timeout * 10))]

                # Create a bidirectional stream with the request iterator and metadata
                chat_stream = self.stub.Chat(request_iterator(), metadata=metadata)

                # Read responses
                try:
                    for message in chat_stream:
                        if not self.running:
                            break
                        receive_callback(message)
                except grpc.RpcError as e:
                    print(f"Error reading chat messages: {e}")

            except grpc.RpcError as e:
                print(f"Error in chat: {e}")

        self.chat_thread = threading.Thread(target=chat_thread_func)
        self.chat_thread.daemon = True
        self.chat_thread.start()
        return True

    def query_data(
        self,
        query_id,
        client_id,
        query_type="exact",
        key=None,
        range_start=None,
        range_end=None,
    ):
        """Query data from the server."""
        # Create a query request
        request = basecamp_pb2.QueryRequest(
            query_id=query_id, client_id=client_id, timestamp=int(time.time() * 1000)
        )

        # Set the query type and parameters
        request.query_type = query_type
        if query_type == "exact" and key is not None:
            request.key = key
        elif (
            query_type == "range" and range_start is not None and range_end is not None
        ):
            request.range_start = range_start
            request.range_end = range_end

        try:
            # Send the query
            response = self.stub.QueryData(request, timeout=self.timeout * 2)

            if response.success:
                print(f"Query successful with {len(response.results)} results")
                if response.from_cache:
                    print("Results served from cache")
                print(f"Processing time: {response.processing_time} ms")
            else:
                print(f"Query failed: {response.error_message}")

            return response
        except grpc.RpcError as e:
            print(f"Error querying data: {e}")
            return None


def main():
    """Main function to demonstrate the client."""
    import argparse

    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Basecamp Python Client")
    parser.add_argument("--address", default="localhost:50051", help="Server address")
    args = parser.parse_args()

    # Create a client
    client = BasecampClient(args.address)

    # Display a menu
    while True:
        print("\nBasecamp Client Menu:")
        print("1. Send a message")
        print("2. Subscribe to updates")
        print("3. Send multiple messages")
        print("4. Start a chat session")
        print("5. Query data")
        print("6. Exit")
        choice = input("Enter your choice: ")

        if choice == "1":
            # Send a message
            sender_id = input("Enter sender ID: ")
            receiver_id = input("Enter receiver ID: ")
            content = input("Enter message content: ")
            client.send_message(sender_id, receiver_id, content)
        elif choice == "2":
            # Subscribe to updates
            subscriber_id = input("Enter subscriber ID: ")
            topics = []
            print("Enter topics (one per line, empty line to finish):")
            while True:
                topic = input()
                if not topic:
                    break
                topics.append(topic)

            def update_callback(update):
                print(f"Received update for topic '{update.topic}': {update.content}")

            client.subscribe_to_updates(subscriber_id, topics, update_callback)
            print("Subscribed to updates successfully")
            input("Press enter to return to the menu...")
        elif choice == "3":
            # Send multiple messages
            sender_id = input("Enter sender ID: ")
            messages = []
            print("Enter messages (receiver and content, empty line to finish):")
            while True:
                receiver_id = input("Enter receiver ID (empty to finish): ")
                if not receiver_id:
                    break
                content = input("Enter message content: ")
                messages.append(
                    {
                        "sender_id": sender_id,
                        "receiver_id": receiver_id,
                        "content": content,
                    }
                )

            client.send_multiple_messages(messages)
        elif choice == "4":
            # Start a chat session
            sender_id = input("Enter sender ID: ")

            def receive_callback(message):
                print(f"{message.sender_id}: {message.content}")

            def get_next_message():
                content = input("Enter message (empty to exit): ")
                if not content:
                    return None
                return content

            client.start_chat(sender_id, receive_callback, get_next_message)
            print("Chat session started successfully")
            print("Enter messages (empty line to exit)")
        elif choice == "5":
            # Query data
            query_id = f"query_{int(time.time())}"
            client_id = input("Enter client ID: ")

            print("Query types:")
            print("1. Exact key query")
            print("2. Range query")
            print("3. All data query")
            query_type_choice = input("Enter query type (1-3): ")

            if query_type_choice == "1":
                query_type = "exact"
                key = int(input("Enter key to query: "))
                response = client.query_data(query_id, client_id, query_type, key=key)
            elif query_type_choice == "2":
                query_type = "range"
                range_start = int(input("Enter range start: "))
                range_end = int(input("Enter range end: "))
                response = client.query_data(
                    query_id,
                    client_id,
                    query_type,
                    range_start=range_start,
                    range_end=range_end,
                )
            elif query_type_choice == "3":
                query_type = "all"
                response = client.query_data(query_id, client_id, query_type)
            else:
                print("Invalid query type")
                continue

            if response:
                print(f"Results ({len(response.results)} items):")
                for i, item in enumerate(response.results[:10]):
                    print(
                        f"  {i}: Key={item.key}, Value={item.value}, Source={item.source_node}"
                    )

                if len(response.results) > 10:
                    print(f"  ... and {len(response.results) - 10} more")

            input("Press enter to return to the menu...")
        elif choice == "6":
            # Exit
            print("Exiting...")
            break
        else:
            print("Invalid choice")


if __name__ == "__main__":
    main()
